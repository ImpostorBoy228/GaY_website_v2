<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–ü—Ä–æ—Å–º–æ—Ç—Ä –≤–∏–¥–µ–æ –ø–æ ID (P2P)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            background: #121212;
            color: #eee;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            background: #1f1f1f;
            padding: 1rem;
            text-align: center;
            font-size: 1.5rem;
        }
        main {
            flex: 1;
            padding: 2rem;
            max-width: 1000px;
            margin: auto;
        }
        video {
            width: 100%;
            border-radius: 8px;
            background: black;
        }
        .input-form {
            margin-bottom: 2rem;
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        .input-form input {
            padding: 0.5rem;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #eee;
            border-radius: 4px;
            flex: 1;
        }
        .input-form button {
            padding: 0.5rem 1rem;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin: 1rem 0;
            background: #2a2a2a;
            padding: 0.75rem;
            border-radius: 8px;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        .stats {
            font-size: 0.9rem;
            color: #aaa;
        }
        .btn-back {
            display: inline-block;
            margin-top: 1rem;
            background: #333;
            padding: 0.5rem 1rem;
            color: white;
            text-decoration: none;
            border-radius: 4px;
        }
        .error {
            color: #f44336;
            margin: 1rem 0;
        }
        footer {
            background: #1f1f1f;
            padding: 1rem;
            text-align: center;
            font-size: 0.8rem;
            color: #777;
        }
        .chunk-controls {
            margin-top: 1rem;
            display: none;
            flex-direction: column;
            gap: 0.5rem;
        }
        .chunk-list {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .chunk-item {
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }
        .chunk-item.available {
            background: #444;
        }
        .chunk-item.loading {
            background: #ffb300;
            color: #000;
        }
        .chunk-item.loaded {
            background: #4caf50;
        }
        .chunk-item:hover {
            opacity: 0.8;
        }
        .load-all-btn {
            padding: 0.5rem 1rem;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 0.5rem;
        }
        .load-all-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        /* –ù–æ–≤—ã–π —Å—Ç–∏–ª—å —Ö–µ–¥–µ—Ä–∞ */
        header {
            background: #111;
            position: fixed;
            width: 100%;
            z-index: 800;
            padding: 0;
        }

        nav {
            position: fixed;
            width: 100%;
            background: rgba(17, 17, 17, 0.9);
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
        }

        .logo {
            height: 75px;
            position: relative;
            display: flex;
            align-items: center;
        }

        .logo:before, .logo:after {
            position: absolute;
            font-size: 7em;
            font-weight: 300;
            line-height: 0;
            color: #fff;
            top: 25px;
        }

        .logo:before {
            content: '\00BB';
            left: 20px;
        }

        .logo:after {
            content: '\00AB';
            left: 34px;
        }

        .logo h1 {
            color: #fff;
            font-size: 1.5em;
            margin-left: 60px;
            font-weight: 400;
        }

        nav ul {
            list-style: none;
            padding: 25px;
            margin: 0;
            display: flex;
            align-items: center;
        }

        nav li {
            margin: 0 10px;
        }

        nav a {
            font-size: 0.9em;
            color: #fff;
            text-decoration: none;
            display: block;
            transition: color 0.3s;
        }

        nav a:hover {
            color: #ccc;
        }

        .search-form {
            display: flex;
            max-width: 400px;
            margin: 0 1rem;
        }

        .search-input {
            padding: 0.5rem;
            flex-grow: 1;
            border-radius: 5px 0 0 5px;
            border: none;
            background: #333;
            color: #e0e0e0;
        }

        .search-button {
            padding: 0.5rem 1rem;
            background: #444;
            color: white;
            border: none;
            border-radius: 0 5px 5px 0;
            cursor: pointer;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .upload-button {
            background: #555;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 5px;
            transition: background 0.3s ease;
            text-decoration: none;
            display: flex;
            align-items: center;
        }

        .upload-button:hover {
            background: #666;
        }

        .user-info img {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid #444;
            object-fit: cover;
        }

        .user-info .username {
            color: #e0e0e0;
            font-weight: bold;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .user-info .username:hover {
            color: #bbb;
        }

        .login-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            font-size: 0.9em;
            cursor: pointer;
            border-radius: 5px;
            transition: background 0.3s ease;
            text-decoration: none;
        }

        .login-button:hover {
            background: #0056b3;
        }

        /* –ú–µ–¥–∏–∞-–∑–∞–ø—Ä–æ—Å—ã –¥–ª—è —Ö–µ–¥–µ—Ä–∞ */
        @media (max-width: 768px) {
            nav {
                flex-wrap: wrap;
                padding: 10px;
            }

            .logo h1 {
                font-size: 1.2em;
            }

            .search-form {
                width: 100%;
                margin: 0.5rem 0;
            }

            nav ul {
                padding: 10px;
                flex-wrap: wrap;
                justify-content: center;
            }

            nav li {
                margin: 5px;
            }

            .user-info {
                gap: 0.3rem;
            }

            .user-info img {
                width: 32px;
                height: 32px;
            }

            .upload-button, .login-button {
                padding: 0.4rem 0.8rem;
                font-size: 0.9rem;
            }

            .user-info .username {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <a href="/"><img src="/static/logo.webp" alt="logo" class="logo"></a>
            <ul>
                <li><a href="{{ url_for('zapros_na_postavku') }}">–ó–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ—Å—Ç–∞–≤–∫—É</a></li>
                <li>
                    <form class="search-form" action="/" method="GET">
                        <input type="text" name="query" placeholder="–ü–æ–∏—Å–∫ –ø–æ –≤–∏–¥–µ–æ..." class="search-input" value="{{ request.args.get('query', '') }}">
                        <button type="submit" class="search-button">–ò—Å–∫–∞—Ç—å</button>
                    </form>
                </li>
                <li class="user-info">
                    {% if current_user.is_authenticated %}
                        <a href="{{ url_for('upload') }}" class="upload-button">+</a>
                        <img src="{{ current_user.avatar or url_for('static', filename='default-avatar.webp') }}" alt="–ê–≤–∞—Ç–∞—Ä">
                        <a href="{{ url_for('dashboard') }}" class="username">{{ current_user.username }}</a>
                    {% else %}
                        <a href="{{ url_for('login') }}" class="login-button">–í–æ–π—Ç–∏</a>
                    {% endif %}
                </li>
            </ul>
        </nav>
        <header>{{ video.title }}</header>
    </header>
    <main>
        {% if video %}
        <h2>{{ video.title }}</h2>
        <div style="position:relative">
            <video id="player" controls></video>
            <button id="activate-btn" style="
                position:absolute;
                top:50%;
                left:50%;
                transform:translate(-50%,-50%);
                padding:12px 20px;
                background:#2196F3;
                color:#fff;
                border:none;
                border-radius:5px;
                cursor:pointer;
                font-size:16px;
                z-index:999;
            ">–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ø–ª–µ–µ—Ä</button>
        </div>
        <div class="controls">
            <span>–†–µ–∂–∏–º:</span>
            <label class="switch">
                <input type="checkbox" id="mode-toggle">
                <span class="slider"></span>
            </label>
            <span id="stream-mode-label">HTTP</span>
        </div>
        <div class="chunk-controls" id="chunk-controls">
            <div class="chunk-list" id="chunk-list"></div>
            <button class="load-all-btn" id="load-all-btn">–ó–∞–≥—Ä—É–∑–∏—Ç—å –≤—Å–µ —á–∞–Ω–∫–∏ —Å —Å–µ—Ä–≤–µ—Ä–∞</button>
        </div>
        <div class="stats" id="p2p-stats" style="display:none">
            ‚ö° –í—ã –≤ P2P-—Ä–µ–∂–∏–º–µ<br>
            ‚Üì <span id="down">0</span> KB/s ‚Äî
            ‚Üë <span id="up">0</span> KB/s ‚Äî
            üßë‚Äçü§ù‚Äçüßë –ü–∏—Ä—ã: <span id="peers">0</span><br>
            üìä –ü—Ä–æ–≥—Ä–µ—Å—Å: <span id="progress">0</span>%
        </div>
        <div style="margin-top:2rem">
            <strong>–ê–≤—Ç–æ—Ä:</strong> {{ video.uploader }}<br>
            <strong>–ü—Ä–æ—Å–º–æ—Ç—Ä—ã:</strong> {{ "{:,}".format(video.views) }}<br>
            <strong>–î–∞—Ç–∞:</strong> {{ video.upload_date.strftime('%d.%m.%Y') }}<br><br>
            <p>{{ video.description }}</p>
        </div>
        {% else %}
        <form class="input-form" method="POST" action="{{ url_for('watch_by_id') }}">
            <input type="text" name="video_id" placeholder="–í–≤–µ–¥–∏—Ç–µ ID –≤–∏–¥–µ–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, By_JYrhx-WY)" required>
            <button type="submit">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
        </form>
        {% endif %}
        {% with messages = get_flashed_messages() %}
        {% if messages %}
        <div class="error">
            {% for message in messages %}
            {{ message }}<br>
            {% endfor %}
        </div>
        {% endif %}
        {% endwith %}
        <a class="btn-back" href="{{ url_for('index') }}">‚Üê –ù–∞–∑–∞–¥</a>
    </main>
    <footer>¬© Dark Lord's Domain, 2025</footer>
    <script>
        {% if video %}
        const video = document.getElementById('player');
        const activateBtn = document.getElementById('activate-btn');
        const toggle = document.getElementById('mode-toggle');
        const label = document.getElementById('stream-mode-label');
        const stats = document.getElementById('p2p-stats');
        const chunkControls = document.getElementById('chunk-controls');
        const chunkList = document.getElementById('chunk-list');
        const loadAllBtn = document.getElementById('load-all-btn');
        const videoId = "{{ video.id | safe }}";
        const httpUrl = "{{ url_for('stream_video', filename=video.file_path) | safe }}";
        const serverUrl = 'http://192.168.1.63:5000';
        console.log('Video ID:', videoId);
        console.log('HTTP URL:', httpUrl);
        console.log('Server URL:', serverUrl);

        let peers = new Map();
        let localPeerId = Math.random().toString(36).slice(2);
        let mediaSource = null;
        let sourceBuffer = null;
        let currentMode = 'http';
        let statsInterval = null;
        let chunkSize = 1024 * 1024; // 1 MB
        let chunks = new Map();
        let chunkStatus = new Map(); // chunkId: 'available'|'loading'|'loaded'
        let totalChunks = 0;
        let downloadedBytes = 0;
        let uploadedBytes = 0;
        let lastStatsTime = Date.now();
        const mimeType = 'video/webm; codecs="vp9, opus"';

        const checkServerAvailability = async () => {
            try {
                const response = await fetch(`${serverUrl}/api/video_metadata/${videoId}`, { method: 'GET', signal: AbortSignal.timeout(5000) });
                if (!response.ok) throw new Error(`Server check failed: ${response.status}`);
                console.log('Server is available');
                return true;
            } catch (err) {
                console.error('Server unavailable:', err.message);
                return false;
            }
        };

        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        const checkCodecSupport = () => {
            if (!window.MediaSource) {
                console.error('MediaSource API not supported');
                return false;
            }
            const isSupported = MediaSource.isTypeSupported(mimeType);
            console.log(`Codec ${mimeType} supported: ${isSupported}`);
            return isSupported;
        };

        const initMediaSource = () => {
            mediaSource = new MediaSource();
            video.src = URL.createObjectURL(mediaSource);
            mediaSource.addEventListener('sourceopen', () => {
                try {
                    sourceBuffer = mediaSource.addSourceBuffer(mimeType);
                    sourceBuffer.mode = 'sequence';
                    console.log('MediaSource opened with', mimeType);
                } catch (err) {
                    console.error('MediaSource error:', err);
                    fallbackToHttp();
                }
            });
        };

        const updateStats = () => {
            const now = Date.now();
            const deltaTime = (now - lastStatsTime) / 1000;
            const downSpeed = (downloadedBytes / deltaTime / 1024).toFixed(1);
            const upSpeed = (uploadedBytes / deltaTime / 1024).toFixed(1);
            downloadedBytes = 0;
            uploadedBytes = 0;
            lastStatsTime = now;
            const progress = totalChunks ? ((chunks.size / totalChunks) * 100).toFixed(1) : 0;
            document.getElementById('down').textContent = downSpeed;
            document.getElementById('up').textContent = upSpeed;
            document.getElementById('peers').textContent = peers.size;
            document.getElementById('progress').textContent = progress;
            console.log(`Stats: ‚Üì ${downSpeed} KB/s, ‚Üë ${upSpeed} KB/s, Peers: ${peers.size}, Progress: ${progress}%`);
        };

        const clearStats = () => {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
            document.getElementById('down').textContent = '0';
            document.getElementById('up').textContent = '0';
            document.getElementById('peers').textContent = '0';
            document.getElementById('progress').textContent = '0';
            downloadedBytes = 0;
            uploadedBytes = 0;
            console.log('Stats cleared');
        };

        const updateChunkUI = () => {
            chunkList.innerHTML = '';
            for (let i = 0; i < totalChunks; i++) {
                const chunkId = `chunk_${i}`;
                const status = chunks.has(chunkId) ? 'loaded' : (chunkStatus.get(chunkId) || 'available');
                chunkStatus.set(chunkId, status);
                const chunkEl = document.createElement('div');
                chunkEl.className = `chunk-item ${status}`;
                chunkEl.textContent = `–ß–∞–Ω–∫ ${i}`;
                chunkEl.dataset.chunkId = chunkId;
                if (status === 'available') {
                    chunkEl.addEventListener('click', () => fetchChunkFromServer(chunkId));
                }
                chunkList.appendChild(chunkEl);
            }
            loadAllBtn.disabled = chunks.size === totalChunks;
            console.log(`Chunk UI updated: ${chunks.size}/${totalChunks} chunks loaded`);
        };

        const setChunkStatus = (chunkId, status) => {
            if (status === 'loaded' && !chunks.has(chunkId)) {
                console.warn(`Attempted to set ${chunkId} as loaded without data`);
                return;
            }
            chunkStatus.set(chunkId, status);
            updateChunkUI();
        };

        const fetchChunkFromServer = async (chunkId, retries = 3) => {
            if (chunkStatus.get(chunkId) === 'loading') {
                console.log(`Chunk ${chunkId} already loading`);
                return;
            }
            if (chunks.has(chunkId)) {
                console.log(`Chunk ${chunkId} already loaded`);
                return;
            }
            if (!(await checkServerAvailability())) {
                console.error(`Cannot fetch ${chunkId}: server unavailable`);
                setChunkStatus(chunkId, 'available');
                return;
            }
            setChunkStatus(chunkId, 'loading');
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    console.log(`Requesting ${chunkId} from server (attempt ${attempt}/${retries})`);
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000);
                    const response = await fetch(`${serverUrl}/api/request_chunks/${videoId}/${localPeerId}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chunkIds: [chunkId] }),
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Server responded with ${response.status}: ${errorText}`);
                    }
                    const result = await response.json();
                    if (result[chunkId]) {
                        const arrayBuffer = new Uint8Array(result[chunkId].match(/.{1,2}/g).map(byte => parseInt(byte, 16))).buffer;
                        chunks.set(chunkId, arrayBuffer);
                        downloadedBytes += arrayBuffer.byteLength;
                        appendChunk(chunkId, arrayBuffer);
                        setChunkStatus(chunkId, 'loaded');
                        console.log(`Fetched ${chunkId} from server, size=${arrayBuffer.byteLength}`);
                        return;
                    } else {
                        throw new Error(`Chunk ${chunkId} not received`);
                    }
                } catch (err) {
                    console.error(`Error fetching ${chunkId} from server (attempt ${attempt}/${retries}):`, err.message);
                    if (err.name === 'AbortError') {
                        console.error(`Request for ${chunkId} timed out`);
                    }
                    if (attempt === retries) {
                        console.error(`Failed to fetch ${chunkId} after ${retries} attempts`);
                        setChunkStatus(chunkId, 'available');
                    }
                    await delay(1000 * attempt); // –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π
                }
            }
        };

        const fetchAllChunksFromServer = async () => {
            const chunkIds = [];
            for (let i = 0; i < totalChunks; i++) {
                const chunkId = `chunk_${i}`;
                if (!chunks.has(chunkId) && chunkStatus.get(chunkId) !== 'loading') {
                    chunkIds.push(chunkId);
                    setChunkStatus(chunkId, 'loading');
                }
            }
            if (!chunkIds.length) {
                console.log('All chunks already loaded or loading');
                return;
            }
            if (!(await checkServerAvailability())) {
                console.error('Cannot fetch all chunks: server unavailable');
                chunkIds.forEach(chunkId => setChunkStatus(chunkId, 'available'));
                loadAllBtn.disabled = false;
                return;
            }
            loadAllBtn.disabled = true;
            try {
                console.log(`Requesting chunks from server: ${chunkIds}`);
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 45000);
                const response = await fetch(`${serverUrl}/api/request_chunks/${videoId}/${localPeerId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ chunkIds }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server responded with ${response.status}: ${errorText}`);
                }
                const result = await response.json();
                for (const chunkId of chunkIds) {
                    if (result[chunkId]) {
                        const arrayBuffer = new Uint8Array(result[chunkId].match(/.{1,2}/g).map(byte => parseInt(byte, 16))).buffer;
                        chunks.set(chunkId, arrayBuffer);
                        downloadedBytes += arrayBuffer.byteLength;
                        appendChunk(chunkId, arrayBuffer);
                        setChunkStatus(chunkId, 'loaded');
                        console.log(`Fetched ${chunkId} from server, size=${arrayBuffer.byteLength}`);
                    } else {
                        console.error(`Failed to fetch ${chunkId}`);
                        setChunkStatus(chunkId, 'available');
                    }
                }
            } catch (err) {
                console.error('Error fetching all chunks from server:', err.message);
                if (err.name === 'AbortError') {
                    console.error('Request for all chunks timed out');
                }
                for (const chunkId of chunkIds) {
                    if (!chunks.has(chunkId)) {
                        setChunkStatus(chunkId, 'available');
                    }
                }
            } finally {
                loadAllBtn.disabled = chunks.size === totalChunks;
            }
        };

        const sendSignal = async (peerId, signal) => {
            try {
                await fetch(`${serverUrl}/api/signal`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ videoId, from: localPeerId, to: peerId, signal })
                });
                console.log(`Signal sent to ${peerId}: ${signal.type}`);
            } catch (err) {
                console.error('Signal send error:', err);
            }
        };

        const connectToPeer = async (peerId) => {
            if (peers.has(peerId) || peerId === localPeerId) {
                console.log(`Skipping connection to ${peerId} (already connected or self)`);
                return;
            }
            console.log(`Initiating connection to peer ${peerId}`);
            const peerConnection = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    {
                        urls: 'turn:127.0.0.1:3478',
                        username: 'impostorboy',
                        credential: 'securePassword123'
                    }
                ]
            });
            const dataChannel = peerConnection.createDataChannel('videoChunks');
            peers.set(peerId, { peerConnection, dataChannel });

            dataChannel.onopen = () => {
                console.log(`DataChannel opened with ${peerId}`);
                requestChunks(peerId);
            };
            dataChannel.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    if (message.type === 'chunk') {
                        if (!chunks.has(message.chunkId)) {
                            const arrayBuffer = new Uint8Array(message.data).buffer;
                            chunks.set(message.chunkId, arrayBuffer);
                            downloadedBytes += arrayBuffer.byteLength;
                            appendChunk(message.chunkId, arrayBuffer);
                            setChunkStatus(message.chunkId, 'loaded');
                            console.log(`Received chunk ${message.chunkId} from ${peerId}, size=${arrayBuffer.byteLength}`);
                        }
                    } else if (message.type === 'request') {
                        sendChunk(peerId, message.chunkId);
                    }
                } catch (err) {
                    console.error(`DataChannel message error from ${peerId}:`, err);
                }
            };
            dataChannel.onclose = () => {
                console.log(`DataChannel closed with ${peerId}`);
                peers.delete(peerId);
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    sendSignal(peerId, { type: 'candidate', candidate: event.candidate });
                }
            };

            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                sendSignal(peerId, { type: 'offer', sdp: offer.sdp });
                console.log(`Offer sent to ${peerId}`);
            } catch (err) {
                console.error('WebRTC offer error:', err);
                peers.delete(peerId);
            }
        };

        const handleSignal = async (data) => {
            if (data.to !== localPeerId) return;
            console.log(`Handling signal from ${data.from}: ${data.signal.type}`);
            let peer = peers.get(data.from);
            if (!peer) {
                console.log(`Creating new peer connection for ${data.from}`);
                const peerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        {
                            urls: 'turn:127.0.0.1:3478',
                            username: 'impostorboy',
                            credential: 'securePassword123'
                        }
                    ]
                });
                peer = { peerConnection, dataChannel: null };
                peers.set(data.from, peer);
                peerConnection.ondatachannel = (event) => {
                    peer.dataChannel = event.channel;
                    peer.dataChannel.onopen = () => {
                        console.log(`DataChannel opened with ${data.from}`);
                        requestChunks(data.from);
                    };
                    peer.dataChannel.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            if (message.type === 'chunk') {
                                if (!chunks.has(message.chunkId)) {
                                    const arrayBuffer = new Uint8Array(message.data).buffer;
                                    chunks.set(message.chunkId, arrayBuffer);
                                    downloadedBytes += arrayBuffer.byteLength;
                                    appendChunk(message.chunkId, arrayBuffer);
                                    setChunkStatus(message.chunkId, 'loaded');
                                    console.log(`Received chunk ${message.chunkId} from ${data.from}, size=${arrayBuffer.byteLength}`);
                                }
                            } else if (message.type === 'request') {
                                sendChunk(data.from, message.chunkId);
                            }
                        } catch (err) {
                            console.error(`DataChannel message error from ${data.from}:`, err);
                        }
                    };
                    peer.dataChannel.onclose = () => {
                        console.log(`DataChannel closed with ${data.from}`);
                        peers.delete(data.from);
                    };
                };
            }

            try {
                if (data.signal.type === 'offer') {
                    await peer.peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: data.signal.sdp }));
                    const answer = await peer.peerConnection.createAnswer();
                    await peer.peerConnection.setLocalDescription(answer);
                    sendSignal(data.from, { type: 'answer', sdp: answer.sdp });
                    console.log(`Answer sent to ${data.from}`);
                } else if (data.signal.type === 'answer') {
                    await peer.peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: data.signal.sdp }));
                    console.log(`Answer received from ${data.from}`);
                } else if (data.signal.type === 'candidate') {
                    await peer.peerConnection.addIceCandidate(new RTCIceCandidate(data.signal.candidate));
                    console.log(`ICE candidate added from ${data.from}`);
                }
            } catch (err) {
                console.error('WebRTC signal error:', err);
                peers.delete(data.from);
            }
        };

        const requestChunks = (peerId) => {
            const peer = peers.get(peerId);
            if (!peer || !peer.dataChannel || peer.dataChannel.readyState !== 'open') {
                console.log(`Cannot request chunks from ${peerId}: channel not open`);
                return;
            }
            let requested = false;
            for (let i = 0; i < totalChunks; i++) {
                const chunkId = `chunk_${i}`;
                if (!chunks.has(chunkId)) {
                    peer.dataChannel.send(JSON.stringify({ type: 'request', chunkId }));
                    console.log(`Requested ${chunkId} from ${peerId}`);
                    requested = true;
                }
            }
            if (!requested) {
                console.log(`No chunks to request from ${peerId}, fetching from server`);
                fetchMissingChunksFromServer();
            }
        };

        const sendChunk = (peerId, chunkId) => {
            const peer = peers.get(peerId);
            if (!peer || !peer.dataChannel || peer.dataChannel.readyState !== 'open') {
                console.log(`Cannot send chunk ${chunkId} to ${peerId}: channel not open`);
                return;
            }
            if (chunks.has(chunkId)) {
                const data = Array.from(new Uint8Array(chunks.get(chunkId)));
                peer.dataChannel.send(JSON.stringify({ type: 'chunk', chunkId, data }));
                uploadedBytes += data.length;
                console.log(`Sent ${chunkId} to ${peerId}, size=${data.length}`);
            } else {
                console.log(`Chunk ${chunkId} not available to send to ${peerId}`);
            }
        };

        const fetchMissingChunksFromServer = async () => {
            const chunkIds = [];
            for (let i = 0; i < totalChunks; i++) {
                const chunkId = `chunk_${i}`;
                if (!chunks.has(chunkId) && chunkStatus.get(chunkId) !== 'loading') {
                    chunkIds.push(chunkId);
                }
            }
            if (!chunkIds.length) {
                console.log('No missing chunks to fetch');
                return;
            }
            console.log(`Fetching missing chunks: ${chunkIds.join(',')}`);
            for (const chunkId of chunkIds) {
                await fetchChunkFromServer(chunkId);
                await delay(500); // –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —á–∞–Ω–∫–∞–º–∏
            }
        };

        const appendChunk = (chunkId, data) => {
            if (!sourceBuffer || sourceBuffer.updating || mediaSource.readyState !== 'open') {
                console.warn('Cannot append chunk: SourceBuffer not ready');
                return;
            }
            try {
                const arrayBuffer = new Uint8Array(data).buffer;
                sourceBuffer.appendBuffer(arrayBuffer);
                console.log(`Appended ${chunkId}`);
            } catch (err) {
                console.error('Append chunk error:', err);
                fallbackToHttp();
            }
        };

        const initHttp = () => {
            peers.forEach((peer, peerId) => {
                if (peer.dataChannel) peer.dataChannel.close();
                if (peer.peerConnection) peer.peerConnection.close();
            });
            peers.clear();
            chunks.clear();
            chunkStatus.clear();
            for (let i = 0; i < totalChunks; i++) {
                chunkStatus.set(`chunk_${i}`, 'available');
            }
            updateChunkUI();
            clearStats();
            video.src = httpUrl;
            video.load();
            stats.style.display = 'none';
            chunkControls.style.display = 'none';
            label.textContent = 'HTTP';
            currentMode = 'http';
            console.log('Switched to HTTP mode');
        };

        const fallbackToHttp = () => {
            console.warn('Falling back to HTTP');
            alert('‚ö†Ô∏è P2P-—Ä–µ–∂–∏–º –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è. –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ HTTP.');
            toggle.checked = false;
            initHttp();
        };

        const initP2P = async () => {
            console.log('Attempting to initialize P2P mode');
            if (!navigator.getUserMedia && !window.RTCPeerConnection) {
                console.warn('WebRTC not supported');
                alert('‚ö†Ô∏è –í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç P2P.');
                toggle.checked = false;
                return initHttp();
            }
            if (!checkCodecSupport()) {
                console.warn('Codec not supported');
                alert('‚ö†Ô∏è –§–æ—Ä–º–∞—Ç –≤–∏–¥–µ–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –¥–ª—è P2P.');
                toggle.checked = false;
                return initHttp();
            }

            initMediaSource();

            try {
                const metaResponse = await fetch(`${serverUrl}/api/video_metadata/${videoId}`, { signal: AbortSignal.timeout(10000) });
                const meta = await metaResponse.json();
                if (meta.error) {
                    console.error('Metadata error:', meta.error);
                    throw new Error('Failed to fetch metadata');
                }
                totalChunks = Math.ceil(meta.size / chunkSize);
                console.log(`Total chunks: ${totalChunks}`);

                chunks.clear();
                chunkStatus.clear();
                for (let i = 0; i < totalChunks; i++) {
                    const chunkId = `chunk_${i}`;
                    chunkStatus.set(chunkId, 'available');
                }
                updateChunkUI();

                const peersResponse = await fetch(`${serverUrl}/api/peers/${videoId}`, { signal: AbortSignal.timeout(10000) });
                const peerList = await peersResponse.json();
                console.log('Available peers:', peerList);

                peerList.forEach(peer => {
                    if (peer.id !== localPeerId) {
                        connectToPeer(peer.id);
                    }
                });

                await fetch(`${serverUrl}/api/register_peer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ videoId, peerId: localPeerId }),
                    signal: AbortSignal.timeout(10000)
                });
                console.log(`Registered peer ${localPeerId} for video ${videoId}`);

                setInterval(async () => {
                    try {
                        const peersResponse = await fetch(`${serverUrl}/api/peers/${videoId}`, { signal: AbortSignal.timeout(10000) });
                        const newPeerList = await peersResponse.json();
                        newPeerList.forEach(peer => {
                            if (peer.id !== localPeerId && !peers.has(peer.id)) {
                                connectToPeer(peer.id);
                            }
                        });
                    } catch (err) {
                        console.error('Peer fetch error:', err);
                    }
                }, 10000);

                const pollSignals = () => {
                    fetch(`${serverUrl}/api/poll_signals/${videoId}/${localPeerId}`, { signal: AbortSignal.timeout(5000) })
                        .then(response => response.json())
                        .then(signals => {
                            if (signals.length > 0) {
                                console.log(`Received ${signals.length} signals for ${localPeerId}`);
                                signals.forEach(handleSignal);
                            }
                        })
                        .catch(err => {
                            console.error('Signal polling error:', err);
                        });
                };
                setInterval(pollSignals, 1000);

                setInterval(fetchMissingChunksFromServer, 10000);

                currentMode = 'p2p';
                label.textContent = 'P2P';
                stats.style.display = 'block';
                chunkControls.style.display = 'flex';
                statsInterval = setInterval(updateStats, 1000);
                console.log('P2P mode initialized');

                fetchMissingChunksFromServer();
            } catch (err) {
                console.error('P2P initialization error:', err);
                fallbackToHttp();
            }
        };

        activateBtn.addEventListener('click', () => {
            console.log('Activate button clicked');
            initHttp();
            activateBtn.remove();
            toggle.disabled = false;
        });

        toggle.addEventListener('change', () => {
            console.log('Mode toggle changed:', toggle.checked);
            if (toggle.checked) {
                initP2P();
            } else {
                initHttp();
            }
        });

        loadAllBtn.addEventListener('click', fetchAllChunksFromServer);

        checkServerAvailability().then(isAvailable => {
            console.log('Initial server check:', isAvailable ? 'OK' : 'Failed');
        });

        toggle.disabled = true;
        {% else %}
        console.log('No video data provided');
        {% endif %}
    </script>
</body>
</html>